-- Create webhooks table
CREATE TABLE IF NOT EXISTS webhooks (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    url TEXT NOT NULL,
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Create materialized view for performance optimization
CREATE MATERIALIZED VIEW IF NOT EXISTS player_performance_summary AS
SELECT 
    p.id,
    p.generation,
    COUNT(pred.id) as total_predictions,
    AVG(pm.accuracy) as avg_accuracy,
    MAX(pm.accuracy) as best_accuracy,
    jsonb_path_query_array(p.dna, '$.weights') as weights
FROM players p
LEFT JOIN predictions pred ON p.id = pred.player_id
LEFT JOIN performance_metrics pm ON p.id = pm.player_id
GROUP BY p.id, p.generation, p.dna;

-- Create index on materialized view
CREATE INDEX IF NOT EXISTS idx_player_performance_generation 
ON player_performance_summary(generation);

-- Function to get player lineage
CREATE OR REPLACE FUNCTION get_player_lineage(player_id BIGINT)
RETURNS TABLE (
    id BIGINT,
    generation INTEGER,
    parent_id BIGINT,
    dna JSONB,
    created_at TIMESTAMP WITH TIME ZONE,
    performance_metrics JSONB
) AS $$
WITH RECURSIVE lineage AS (
    -- Base case: start with the given player
    SELECT 
        p.id,
        p.generation,
        p.parent_id,
        p.dna,
        p.created_at,
        jsonb_build_object(
            'accuracy', ps.avg_accuracy,
            'predictions', ps.total_predictions,
            'best_accuracy', ps.best_accuracy
        ) as performance_metrics
    FROM players p
    LEFT JOIN player_performance_summary ps ON p.id = ps.id
    WHERE p.id = $1

    UNION ALL

    -- Recursive case: get all ancestors
    SELECT 
        p.id,
        p.generation,
        p.parent_id,
        p.dna,
        p.created_at,
        jsonb_build_object(
            'accuracy', ps.avg_accuracy,
            'predictions', ps.total_predictions,
            'best_accuracy', ps.best_accuracy
        ) as performance_metrics
    FROM players p
    LEFT JOIN player_performance_summary ps ON p.id = ps.id
    INNER JOIN lineage l ON p.id = l.parent_id
)
SELECT * FROM lineage;
$$ LANGUAGE sql;

-- Create maintenance function for materialized views
CREATE OR REPLACE FUNCTION refresh_materialized_views()
RETURNS void AS $$
BEGIN
    REFRESH MATERIALIZED VIEW CONCURRENTLY player_performance_summary;
END;
$$ LANGUAGE plpgsql;

-- Create a scheduled job to refresh materialized views
SELECT cron.schedule(
    'refresh_materialized_views_job',
    '0 */6 * * *', -- A cada 6 horas
    'SELECT refresh_materialized_views()'
);